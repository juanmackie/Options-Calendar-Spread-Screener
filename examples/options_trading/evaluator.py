"""
Evaluator for options trading algorithms.

This script backtests trading algorithms generated by OpenEvolve.
It simulates trading over historical options data and calculates performance metrics.
"""
import importlib.util
import importlib.util
import os
import sys
import time
import traceback
import numpy as np
import pandas as pd # Placeholder, may not be used if API returns other formats
import random # Added for mock data generation
import tempfile # Added for the __main__ test block

# --- Configuration ---
INITIAL_CAPITAL = 100000  # Starting capital for backtesting
COMMISSION_PER_CONTRACT = 0.65  # Example commission
SLIPPAGE_PER_CONTRACT = 0.01 # Example slippage per share/contract for market orders

# --- API Integration Placeholder ---
# IMPORTANT: This section needs to be replaced with actual API integration logic
# to fetch historical options data for backtesting.

def fetch_historical_data(start_date_str, end_date_str, underlying_symbol, option_types=['call', 'put'], strike_range_pct=0.1, api_key=None, api_endpoint=None):
    """
    Fetches historical options data. This is a placeholder and currently returns MOCK DATA.
    Replace the mock data generation with actual API calls.

    Expected Data Structure for each element in the returned list:
    {
        'timestamp': str (e.g., 'YYYY-MM-DD HH:MM:SS'),
        'underlying_price': float,
        'options_chain': [
            {
                'symbol': str (unique option contract identifier),
                'type': str ('call' or 'put'),
                'strike': float,
                'expiry': str (e.g., 'YYYY-MM-DD'),
                'bid': float,
                'ask': float,
                'last': float (optional, last traded price),
                'volume': int (optional),
                'open_interest': int (optional),
                'iv': float (implied volatility, optional),
                'delta': float (optional),
                'gamma': float (optional),
                'theta': float (optional),
                'vega': float (optional)
            },
            # ... more option contracts for this timestamp ...
        ]
    }

    Args:
        start_date_str (str): Start date for data (e.g., '2023-01-01').
        end_date_str (str): End date for data (e.g., '2023-01-31').
        underlying_symbol (str): Symbol of the underlying asset (e.g., 'SPY').
        option_types (list): Types of options to fetch.
        strike_range_pct (float): Pct around underlying price for strike selection.
        api_key (str, optional): API key for the data provider.
        api_endpoint (str, optional): API endpoint URL.

    Returns:
        list of dicts: A list of market snapshots, chronological. Returns mock data for now.
    """
    print(f"INFO: Using MOCK data for {underlying_symbol} from {start_date_str} to {end_date_str}.")
    print("INFO: To use real data, replace the mock data generation in 'fetch_historical_data' with your API calls.")

    # --- START OF MOCK DATA GENERATION ---
    # This section should be replaced by your actual API calls.
    full_mock_data = []
    current_date = pd.to_datetime(start_date_str)
    end_date = pd.to_datetime(end_date_str)

    base_underlying_price = 400.0  # Starting price for mock data
    day_idx = 0

    while current_date <= end_date:
        # Simulate a few snapshots per day (e.g., 9:30, 12:00, 15:30)
        for time_of_day in ["09:30:00", "12:00:00", "15:30:00"]:
            timestamp_str = f"{current_date.strftime('%Y-%m-%d')} {time_of_day}"

            # Simulate underlying price movement
            price_movement = (random.random() - 0.5) * 5 # Random movement +/- 2.5
            current_underlying_price = round(base_underlying_price + price_movement + (day_idx * 0.1), 2) # Slight upward drift over days

            options_chain = []
            # Generate a few call and put options around the current underlying price
            for opt_type in option_types:
                for strike_offset_pct in [-0.05, -0.02, 0, 0.02, 0.05]: # 5%, 2% OTM, ATM, 2%, 5% ITM
                    strike = round(current_underlying_price * (1 + strike_offset_pct) / 5) * 5 # Round to nearest 5

                    # Simulate option prices (very crudely)
                    intrinsic_value = 0
                    if opt_type == 'call':
                        intrinsic_value = max(0, current_underlying_price - strike)
                    else: # put
                        intrinsic_value = max(0, strike - current_underlying_price)

                    time_value = round(current_underlying_price * 0.01 * (1 + random.random()), 2) # Small random time value

                    mock_option_price = round(intrinsic_value + time_value, 2)
                    mock_iv = round(0.15 + random.random() * 0.1, 3) # IV between 0.15 and 0.25
                    mock_delta = round(0.5 + (random.random() - 0.5) * 0.4 if opt_type == 'call' else -0.5 + (random.random() - 0.5) * 0.4, 3)


                    options_chain.append({
                        'symbol': f"{underlying_symbol}{current_date.strftime('%y%m%d')}{opt_type[0].upper()}{str(int(strike*1000)).zfill(8)}",
                        'type': opt_type,
                        'strike': strike,
                        'expiry': (current_date + pd.Timedelta(days=30)).strftime('%Y-%m-%d'), # Mock expiry 30 days out
                        'bid': round(max(0.01, mock_option_price - 0.05), 2), # Ensure bid > 0
                        'ask': round(max(0.02, mock_option_price + 0.05), 2), # Ensure ask > bid
                        'last': round(mock_option_price, 2),
                        'volume': random.randint(10, 500),
                        'open_interest': random.randint(100, 2000),
                        'iv': mock_iv,
                        'delta': mock_delta,
                        'gamma': round(random.random() * 0.05, 4),
                        'theta': round(-random.random() * 0.05, 4),
                        'vega': round(random.random() * 0.2, 4),
                        'underlying_price': current_underlying_price
                    })

            full_mock_data.append({
                'timestamp': timestamp_str,
                'underlying_price': current_underlying_price,
                'options_chain': options_chain
            })

        current_date += pd.Timedelta(days=1)
        day_idx += 1
        if len(full_mock_data) >= 200: # Limit mock data size for quick tests
            print(f"INFO: Mock data generation reached limit of {len(full_mock_data)} snapshots.")
            break

    # --- END OF MOCK DATA GENERATION ---

    # If you were calling a real API, it might look something like this:
    # params = {
    #     'apikey': api_key,
    #     'symbol': underlying_symbol,
    #     'start_date': start_date_str,
    #     'end_date': end_date_str,
    #     # ... other API specific parameters
    # }
    # response = requests.get(api_endpoint, params=params)
    # response.raise_for_status() # Raise an exception for HTTP errors
    # api_data = response.json()
    # formatted_data = transform_api_data_to_expected_format(api_data) # You'd need this transformation function
    # return formatted_data

    return full_mock_data

# --- Backtesting Engine ---

class Portfolio:
    def __init__(self, initial_capital):
        self.cash = initial_capital
        self.initial_capital = initial_capital
        self.positions = {}  # {'contract_symbol': {'quantity': X, 'entry_price_per_contract': Y}}
        self.trade_log = []
        self.equity_curve = [{'timestamp': None, 'equity': initial_capital}]

    def update_equity(self, timestamp, market_data):
        current_equity = self.cash
        for symbol, details in self.positions.items():
            # Corrected generator expression:
            # Iterate through each option 'opt' in the 'options_chain'
            # and find the one where 'opt['symbol']' matches the 'symbol' from positions.
            option_data = next((opt for opt in market_data.get('options_chain', []) if opt['symbol'] == symbol), None)
            if option_data:
                # Value based on bid for long, ask for short (conservative)
                price = option_data['bid'] if details['quantity'] > 0 else option_data['ask']
                current_equity += details['quantity'] * price * 100 # Options typically control 100 shares
            else:
                # If option data not found (e.g. expired, delisted), might need complex handling.
                # For simplicity, assume it's worth 0 if not in current market data.
                # A more robust backtester would handle expirations explicitly.
                pass
        self.equity_curve.append({'timestamp': timestamp, 'equity': round(current_equity,2)})

    def execute_trade(self, trade_order, market_data_snapshot):
        """
        Executes a trade and updates portfolio.
        trade_order: {'action': 'BUY'/'SELL', 'contract_symbol': str, 'quantity': int, 'price': float, 'order_type': 'MARKET'/'LIMIT'}
        """
        contract_symbol = trade_order['contract_symbol']
        quantity = trade_order['quantity']
        action = trade_order['action']

        option_data = next((opt for opt in market_data_snapshot.get('options_chain', []) if opt['symbol'] == contract_symbol), None)
        if not option_data:
            self.log_trade(market_data_snapshot['timestamp'], action, contract_symbol, quantity, 0, "FAILED - No market data for contract")
            return False

        trade_price = 0
        if action == "BUY":
            trade_price = option_data['ask'] + SLIPPAGE_PER_CONTRACT # Buy at ask + slippage
        elif action == "SELL":
            trade_price = option_data['bid'] - SLIPPAGE_PER_CONTRACT # Sell at bid - slippage

        if trade_price <= 0: # Cannot trade at zero or negative price
            self.log_trade(market_data_snapshot['timestamp'], action, contract_symbol, quantity, trade_price, "FAILED - Invalid trade price")
            return False

        cost_or_proceeds = trade_price * quantity * 100 # Standard 100 shares per contract
        commission = COMMISSION_PER_CONTRACT * quantity

        if action == "BUY":
            if self.cash < cost_or_proceeds + commission:
                self.log_trade(market_data_snapshot['timestamp'], action, contract_symbol, quantity, trade_price, "FAILED - Insufficient cash")
                return False
            self.cash -= (cost_or_proceeds + commission)
            current_qty = self.positions.get(contract_symbol, {}).get('quantity', 0)
            current_avg_price = self.positions.get(contract_symbol, {}).get('entry_price_per_contract', 0)
            new_qty = current_qty + quantity
            if new_qty == 0: # Should not happen for BUY if current_qty is 0 or positive
                 del self.positions[contract_symbol]
            else:
                new_avg_price = ((current_avg_price * current_qty) + (trade_price * quantity)) / new_qty if current_qty != 0 else trade_price
                self.positions[contract_symbol] = {'quantity': new_qty, 'entry_price_per_contract': new_avg_price}

        elif action == "SELL": # Selling to close a long or open a short
            current_qty = self.positions.get(contract_symbol, {}).get('quantity', 0)
            # Note: This simple backtester doesn't robustly handle short selling margin/rules.
            # Assume selling reduces existing long or goes short (negative quantity).
            if current_qty > 0 and quantity > current_qty: # Selling more than held (partially closing, partially shorting)
                # This case needs careful handling of P&L for the closed part.
                # For simplicity, we'll just update quantity. A real backtester needs more.
                pass

            self.cash += (cost_or_proceeds - commission)
            new_qty = current_qty - quantity
            if new_qty == 0:
                if contract_symbol in self.positions:
                    del self.positions[contract_symbol]
            else:
                # Average price for shorts is complex; for simplicity, keep entry of original if qty remains.
                # If going from long to short, or vice-versa, avg price resets.
                current_avg_price = self.positions.get(contract_symbol, {}).get('entry_price_per_contract', trade_price)
                if (current_qty > 0 and new_qty < 0) or (current_qty < 0 and new_qty > 0): # Flipped position
                     self.positions[contract_symbol] = {'quantity': new_qty, 'entry_price_per_contract': trade_price}
                else:
                     self.positions[contract_symbol] = {'quantity': new_qty, 'entry_price_per_contract': current_avg_price}


        self.log_trade(market_data_snapshot['timestamp'], action, contract_symbol, quantity, trade_price, "EXECUTED")
        return True

    def log_trade(self, timestamp, action, symbol, qty, price, status):
        self.trade_log.append({
            'timestamp': timestamp, 'action': action, 'symbol': symbol,
            'quantity': qty, 'price': price, 'status': status
        })

    def calculate_metrics(self):
        final_equity = self.equity_curve[-1]['equity']
        total_pnl = final_equity - self.initial_capital
        profit_loss_pct = (total_pnl / self.initial_capital) * 100

        returns = pd.Series([eq['equity'] for eq in self.equity_curve]).pct_change().dropna()
        sharpe_ratio = 0
        if not returns.empty and returns.std() != 0:
            # Assuming 252 trading days for annualization, risk-free rate 0
            sharpe_ratio = (returns.mean() / returns.std()) * np.sqrt(252) if returns.std() > 0 else 0

        equity_values = np.array([eq['equity'] for eq in self.equity_curve])
        peak = np.maximum.accumulate(equity_values)
        drawdown = (equity_values - peak) / peak
        max_drawdown = np.min(drawdown) if len(drawdown) > 0 and np.any(drawdown < 0) else 0

        executed_trades = [t for t in self.trade_log if t['status'] == 'EXECUTED']
        num_trades = len(executed_trades)

        # Simplified win rate (number of profitable days, not trades)
        daily_returns = pd.Series(equity_values).diff().dropna()
        win_rate = (daily_returns > 0).sum() / len(daily_returns) if len(daily_returns) > 0 else 0

        avg_profit_per_trade = total_pnl / num_trades if num_trades > 0 else 0

        # Example combined_score (can be tuned)
        # Penalize heavily for large drawdowns or very low Sharpe
        score = (sharpe_ratio * 0.5) + (profit_loss_pct * 0.005) + (max_drawdown * 5) # max_drawdown is negative
        if num_trades < 5: score -= 0.5 # Penalize for too few trades
        if profit_loss_pct < -50 : score -= 2 # Heavy penalty for huge losses

        return {
            'total_profit_loss': round(total_pnl, 2),
            'profit_loss_pct': round(profit_loss_pct, 2),
            'sharpe_ratio': round(sharpe_ratio, 3),
            'max_drawdown_pct': round(max_drawdown * 100, 2),
            'win_rate_daily': round(win_rate * 100, 2),
            'number_of_trades': num_trades,
            'average_profit_per_trade': round(avg_profit_per_trade, 2),
            'final_equity': round(final_equity, 2),
            'combined_score': round(score, 4) # Main metric for OpenEvolve
        }

# --- Evaluation Function ---

def evaluate(program_path: str) -> dict:
    """
    Evaluates a given trading algorithm program.
    """
    try:
        # Load the trading algorithm from the provided path
        spec = importlib.util.spec_from_file_location("trading_module", program_path)
        if spec is None or spec.loader is None:
            raise ImportError(f"Could not load spec for {program_path}")
        trading_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(trading_module)

        if not hasattr(trading_module, 'get_trading_algorithm'):
            raise AttributeError("Program does not have 'get_trading_algorithm' function.")

        trading_algorithm_func = trading_module.get_trading_algorithm()
        if not callable(trading_algorithm_func):
            raise TypeError("'get_trading_algorithm' did not return a callable function.")

        # Fetch historical data (using mock for now)
        # TODO: Parameterize dates and symbols based on config or problem definition
        historical_data = fetch_historical_data('2023-10-01', '2023-12-31', 'SPY')
        if not historical_data:
            return {'error': 1.0, 'message': "Failed to fetch historical data (mock).", 'combined_score': -1000}

        # Initialize portfolio and backtesting parameters
        portfolio = Portfolio(INITIAL_CAPITAL)
        # Parameters for the trading algorithm itself (can be evolved or fixed)
        algo_parameters = {
            'max_risk_per_trade': 0.02,
            'target_profit_pct': 0.10,
            'hold_period_days': 5, # Example parameter
            'enable_buys': True,
            'enable_sells': False, # Default to no short selling for simplicity
            'max_trades_per_step': 1
        }

        # Backtesting loop
        for i, market_snapshot in enumerate(historical_data):
            # Prepare data for the algorithm for the current time step
            # The algorithm might need a window of past data, not just the current snapshot.
            # For this example, we pass data up to current snapshot.
            current_data_window = historical_data[:i+1]

            try:
                trade_orders = trading_algorithm_func(current_data_window, portfolio.positions.copy(), algo_parameters)
            except Exception as algo_exc:
                print(f"ERROR in trading_algorithm_func: {algo_exc}")
                traceback.print_exc()
                # Penalize algorithm errors, but don't stop evaluation
                return {'error': 1.0, 'message': f"Algorithm runtime error: {algo_exc}", 'combined_score': -1000}


            if trade_orders:
                for order in trade_orders:
                    portfolio.execute_trade(order, market_snapshot)

            portfolio.update_equity(market_snapshot['timestamp'], market_snapshot)

        # Calculate final metrics
        metrics = portfolio.calculate_metrics()
        metrics['eval_time'] = time.time() # Placeholder, actual timing should be done by OpenEvolve

        # Ensure 'combined_score' is present, as it's often the target
        if 'combined_score' not in metrics:
            metrics['combined_score'] = -1000 # Default if not calculated

        return metrics

    except ImportError:
        return {'error': 1.0, 'message': f"Failed to import trading algorithm: {program_path}", 'combined_score': -1000}
    except AttributeError as e:
        return {'error': 1.0, 'message': f"Attribute error in trading algorithm: {e}", 'combined_score': -1000}
    except Exception as e:
        print(f"CRITICAL EVALUATION ERROR for {program_path}: {e}")
        traceback.print_exc()
        return {'error': 1.0, 'message': f"Unhandled exception during evaluation: {e}", 'combined_score': -1000}

# Example of how OpenEvolve might call this (for testing the evaluator itself)
if __name__ == "__main__":
    # Create a dummy program file to test the evaluator
    dummy_program_content = """
import random

def generate_trades_logic(historical_data, current_holdings, parameters):
    trades = []
    if not historical_data: return trades
    latest_snapshot = historical_data[-1]
    if 'options_chain' in latest_snapshot and latest_snapshot['options_chain']:
        option_to_trade = random.choice(latest_snapshot['options_chain'])
        if random.random() < 0.1: # 10% chance to trade
            action_type = 'BUY' if random.random() < 0.5 else 'SELL'
            trades.append({
                'action': action_type,
                'contract_symbol': option_to_trade['symbol'],
                'quantity': 1,
                'price': option_to_trade['ask'] if action_type == 'BUY' else option_to_trade['bid'],
                'order_type': 'MARKET'
            })
    return trades

def get_trading_algorithm():
    return generate_trades_logic
"""
    temp_program_file = tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False)
    temp_program_file.write(dummy_program_content)
    temp_program_file_path = temp_program_file.name
    temp_program_file.close()

    print(f"Evaluating dummy program: {temp_program_file_path}")
    results = evaluate(temp_program_file_path)
    print("\nEvaluation Results:")
    for key, value in results.items():
        print(f"  {key}: {value}")

    os.unlink(temp_program_file_path)

    # Test with the initial_program.py if it exists in the current dir for convenience
    # Adjust path if evaluator.py is not in the same directory as initial_program.py during standalone run.
    # Assuming they are in the same directory for this example: examples/options_trading/
    current_dir = os.path.dirname(os.path.abspath(__file__))
    initial_program_path_test = os.path.join(current_dir, "initial_program.py")

    if os.path.exists(initial_program_path_test):
        print(f"\nEvaluating local initial_program.py: {initial_program_path_test}")
        results = evaluate(initial_program_path_test)
        print("\nEvaluation Results for initial_program.py:")
        for key, value in results.items():
            print(f"  {key}: {value}")
    else:
        print(f"\nSkipping evaluation of local initial_program.py (not found at {initial_program_path_test})")
